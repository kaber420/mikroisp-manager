import multiprocessing
import os
import sys
import time
import argparse
import socket
import secrets
from dotenv import load_dotenv

def _ensure_env():
    """Generates .env if missing or incomplete."""
    if not os.path.exists(ENV_FILE):
        print(f"‚ö†Ô∏è  {ENV_FILE} not found. Generating default configuration...")
        try:
            from cryptography.fernet import Fernet
            encrypt_key = Fernet.generate_key().decode()
        except ImportError:
            import base64
            encrypt_key = base64.urlsafe_b64encode(os.urandom(32)).decode()

        secret_key = secrets.token_hex(32)
        lan_ip = get_lan_ip()
        
        content = (
            f"# Auto-generated by Launcher\n"
            f"UVICORN_PORT=7777\n"
            f'SECRET_KEY="{secret_key}"\n'
            f'ENCRYPTION_KEY="{encrypt_key}"\n'
            f"APP_ENV=production\n"
            f"ALLOWED_ORIGINS=http://localhost:7777,http://{lan_ip}:7777\n"
            f"ALLOWED_HOSTS=localhost,127.0.0.1,{lan_ip}:7777\n"
            f"UVICORN_WORKERS=1\n"
            f"FLUTTER_DEV=false\n"
        )
        
        with open(ENV_FILE, "w") as f:
            f.write(content)
        print(f"‚úÖ Created {ENV_FILE} with secure keys.")

    else:
        with open(ENV_FILE, "r") as f:
            current_env = f.read()
        
        updates = []
        if "SECRET_KEY" not in current_env:
            updates.append(f'SECRET_KEY="{secrets.token_hex(32)}"')
        if "ENCRYPTION_KEY" not in current_env:
            try:
                from cryptography.fernet import Fernet
                k = Fernet.generate_key().decode()
            except:
                import base64
                k = base64.urlsafe_b64encode(os.urandom(32)).decode()
            updates.append(f'ENCRYPTION_KEY="{k}"')
            
        if updates:
            print(f"‚ö†Ô∏è  Updating {ENV_FILE} with missing keys...")
            with open(ENV_FILE, "a") as f:
                f.write("\n" + "\n".join(updates) + "\n")
            print("‚úÖ Keys added.")

# Ensure app path is in sys.path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from launcher.constants import ENV_FILE
from launcher.user_setup import check_and_create_first_user
from launcher.network import get_lan_ip
from launcher.caddy import is_caddy_running, start_caddy_if_needed
from launcher.server import start_api_process

# Commands
from launcher.commands.diagnose import DiagnoseCommand
from launcher.commands.management import ManagementCommand
from launcher.commands.setup import SetupCommand
from launcher.config import config_manager

# TUI
from launcher.tui import TUIApp

def run_server(args):
    # --- Verificaciones Previas ---
    # Init Logging Queue
    log_queue = multiprocessing.Queue()
    
    # Configure logging for the main process to use the queue
    from launcher.log_queue import configure_process_logging
    configure_process_logging(log_queue)
    
    # Initialize Service Manager
    from launcher.services import ServiceManager
    service_manager = ServiceManager(log_queue, args)

    try:
        # Start Services
        service_manager.start_all()
        
        # Mode is already resolved in main() and stored in args.headless
        is_headless = args.headless
        
        if is_headless:
            # Headless Mode: Log Monitor
            info = service_manager.server_info
            print(f"Server running in HEADLESS mode.")
            print(f"Management: {info['local_url']}")
            print("-" * 50)
            print(" OPCIONES DE RECUPERACI√ìN:")
            print(" 1. Solo esta vez (Rescue):   python launcher/main.py --tui")
            print(" 2. Cambiar para siempre:     python launcher/main.py --tui --save")
            print("-" * 50)
            print("Showing live logs (Ctrl+C to stop)...")
            
            import queue
            while True:
                try:
                    # Non-blocking get with timeout to allow checking for signals
                    record = log_queue.get(timeout=0.5)
                    # Simple formatting: [LEVEL] Source: Message
                    print(f"[{record.levelname}] {record.name}: {record.msg}")
                except queue.Empty:
                    continue
        else:
            # TUI Mode
            # Pass service_manager instead of just server_info
            tui = TUIApp(log_queue, service_manager)
            tui.run()

    except KeyboardInterrupt:
        pass
    finally:
        service_manager.stop_all()
        sys.exit(0)

def main():
    multiprocessing.freeze_support()
    
    # Ensure environment exists
    _ensure_env()

    # Load .env early for fallback values
    load_dotenv(ENV_FILE)
    
    parser = argparse.ArgumentParser(description="¬µMonitor Pro Launcher")
    subparsers = parser.add_subparsers(dest="command", help="Comandos disponibles")

    # Instantiate and register commands
    commands = {}

    # Diagnose
    diag_parser = subparsers.add_parser("diagnose", help="Diagn√≥stico del sistema")
    commands["diagnose"] = DiagnoseCommand(diag_parser)

    # Manage
    mgmt_parser = subparsers.add_parser("manage", help="Gesti√≥n del sistema")
    commands["manage"] = ManagementCommand(mgmt_parser)

    # Setup
    setup_parser = subparsers.add_parser("setup", help="Asistente de configuraci√≥n")
    commands["setup"] = SetupCommand(setup_parser)

    # Server Arguments (Default)
    parser.add_argument("--headless", action="store_true", help="Ejecutar sin interfaz gr√°fica (Headless)")
    parser.add_argument("--tui", action="store_true", help="Forzar ejecuci√≥n con interfaz gr√°fica (TUI)")
    parser.add_argument("--save", action="store_true", help="Guardar la preferencia de modo (--tui o --headless) en la configuraci√≥n")
    parser.add_argument("--webworkers", type=int, default=None, help="N√∫mero de workers de Uvicorn (ej: --webworkers 4)")
    parser.add_argument("--port", type=int, default=None, help="Puerto de escucha de Uvicorn (ej: --port 8100)")
    parser.add_argument("--show", action="store_true", help="Mostrar configuraci√≥n actual y salir")
    parser.add_argument("--interactive", action="store_true", help="Forzar creaci√≥n interactiva del primer usuario en terminal")

    args = parser.parse_args()

    # --- Resolve Headless Mode ---
    # Priority: 1. CLI flags, 2. Saved config, 3. Default (False)
    target_headless = None
    if args.tui:
        is_headless = False
        target_headless = False
    elif args.headless:
        is_headless = True
        target_headless = True
    else:
        is_headless = config_manager.get("headless", False)
        target_headless = None

    # --- Resolve Web Workers ---
    # Priority: 1. CLI, 2. config_manager, 3. .env
    if args.webworkers is not None:
        web_workers = args.webworkers
    else:
        saved_workers = config_manager.get("web_workers")
        if saved_workers is not None:
            web_workers = saved_workers
        else:
            web_workers = int(os.getenv("UVICORN_WORKERS", "1"))

    # --- Resolve Port ---
    # Priority: 1. CLI, 2. config_manager, 3. .env
    if args.port is not None:
        port = args.port
    else:
        saved_port = config_manager.get("port")
        if saved_port is not None:
            port = saved_port
        else:
            port = int(os.getenv("UVICORN_PORT", "7777"))

    # --- Handle --save ---
    if args.save:
        save_msg_parts = []
        if target_headless is not None:
            config_manager.set("headless", target_headless)
            mode_str = "HEADLESS" if target_headless else "TUI"
            save_msg_parts.append(f"Modo: {mode_str}")
        if args.webworkers is not None:
            config_manager.set("web_workers", args.webworkers)
            save_msg_parts.append(f"Workers: {args.webworkers}")
        if args.port is not None:
            config_manager.set("port", args.port)
            save_msg_parts.append(f"Puerto: {args.port}")
        
        if save_msg_parts:
            print(f"‚úÖ Configuraci√≥n guardada: {', '.join(save_msg_parts)}")

    # Inject resolved values into args for run_server and ServiceManager
    args.headless = is_headless
    args.web_workers = web_workers
    args.resolved_port = port

    if args.command in commands:
        commands[args.command].run(args)
    elif args.show:
        # Show config and exit
        print(f"üìÇ Archivo de configuraci√≥n: {config_manager.config_path}")
        print("‚öôÔ∏è  Configuraci√≥n guardada:")
        if config_manager.config:
            for k, v in config_manager.config.items():
                print(f"   - {k}: {v}")
        else:
            print("   (vac√≠a)")
        print(f"\nüìÑ Variables de entorno ({ENV_FILE}):")
        print(f"   - UVICORN_PORT={port}")
        print(f"   - UVICORN_WORKERS={web_workers}")
    else:
        # Default action: Run Server
        run_server(args)

if __name__ == "__main__":
    main()

